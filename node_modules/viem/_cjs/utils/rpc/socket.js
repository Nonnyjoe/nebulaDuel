"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSocketRpcClient = exports.socketClientCache = void 0;
const request_js_1 = require("../../errors/request.js");
const createBatchScheduler_js_1 = require("../promise/createBatchScheduler.js");
const withTimeout_js_1 = require("../promise/withTimeout.js");
const id_js_1 = require("./id.js");
exports.socketClientCache = new Map();
async function getSocketRpcClient(params) {
    const { getSocket, url } = params;
    let socketClient = exports.socketClientCache.get(url);
    if (socketClient)
        return socketClient;
    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: url,
        fn: async () => {
            const requests = new Map();
            const subscriptions = new Map();
            const socket = await getSocket({
                onResponse(data) {
                    const isSubscription = data.method === 'eth_subscription';
                    const id = isSubscription ? data.params.subscription : data.id;
                    const cache = isSubscription ? subscriptions : requests;
                    const callback = cache.get(id);
                    if (callback)
                        callback(data);
                    if (!isSubscription)
                        cache.delete(id);
                },
            });
            socketClient = {
                close() {
                    socket.close();
                    exports.socketClientCache.delete(url);
                },
                socket,
                request({ body, onError, onResponse }) {
                    const id = body.id ?? id_js_1.idCache.take();
                    const callback = (response) => {
                        if (typeof response.id === 'number' && id !== response.id)
                            return;
                        if (body.method === 'eth_subscribe' &&
                            typeof response.result === 'string')
                            subscriptions.set(response.result, callback);
                        if (body.method === 'eth_unsubscribe')
                            subscriptions.delete(body.params?.[0]);
                        onResponse(response);
                    };
                    requests.set(id, callback);
                    try {
                        socket.request({
                            body: {
                                jsonrpc: '2.0',
                                id,
                                ...body,
                            },
                        });
                    }
                    catch (error) {
                        onError?.(error);
                    }
                },
                requestAsync({ body, timeout = 10000 }) {
                    return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse, onError) => this.request({
                        body,
                        onError,
                        onResponse,
                    })), {
                        errorInstance: new request_js_1.TimeoutError({ body, url }),
                        timeout,
                    });
                },
                requests,
                subscriptions,
                url,
            };
            exports.socketClientCache.set(url, socketClient);
            return [socketClient];
        },
    });
    const [_, [socketClient_]] = await schedule();
    return socketClient_;
}
exports.getSocketRpcClient = getSocketRpcClient;
//# sourceMappingURL=socket.js.map