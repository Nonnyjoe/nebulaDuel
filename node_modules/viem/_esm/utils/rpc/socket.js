import { TimeoutError } from '../../errors/request.js';
import { createBatchScheduler, } from '../promise/createBatchScheduler.js';
import { withTimeout } from '../promise/withTimeout.js';
import { idCache } from './id.js';
export const socketClientCache = /*#__PURE__*/ new Map();
export async function getSocketRpcClient(params) {
    const { getSocket, url } = params;
    let socketClient = socketClientCache.get(url);
    // If the socket already exists, return it.
    if (socketClient)
        return socketClient;
    const { schedule } = createBatchScheduler({
        id: url,
        fn: async () => {
            // Set up a cache for incoming "synchronous" requests.
            const requests = new Map();
            // Set up a cache for subscriptions (eth_subscribe).
            const subscriptions = new Map();
            // Set up socket implementation.
            const socket = await getSocket({
                onResponse(data) {
                    const isSubscription = data.method === 'eth_subscription';
                    const id = isSubscription ? data.params.subscription : data.id;
                    const cache = isSubscription ? subscriptions : requests;
                    const callback = cache.get(id);
                    if (callback)
                        callback(data);
                    if (!isSubscription)
                        cache.delete(id);
                },
            });
            // Create a new socket instance.
            socketClient = {
                close() {
                    socket.close();
                    socketClientCache.delete(url);
                },
                socket,
                request({ body, onError, onResponse }) {
                    const id = body.id ?? idCache.take();
                    const callback = (response) => {
                        if (typeof response.id === 'number' && id !== response.id)
                            return;
                        // If we are subscribing to a topic, we want to set up a listener for incoming
                        // messages.
                        if (body.method === 'eth_subscribe' &&
                            typeof response.result === 'string')
                            subscriptions.set(response.result, callback);
                        // If we are unsubscribing from a topic, we want to remove the listener.
                        if (body.method === 'eth_unsubscribe')
                            subscriptions.delete(body.params?.[0]);
                        onResponse(response);
                        // TODO: delete request?
                    };
                    requests.set(id, callback);
                    try {
                        socket.request({
                            body: {
                                jsonrpc: '2.0',
                                id,
                                ...body,
                            },
                        });
                    }
                    catch (error) {
                        onError?.(error);
                    }
                },
                requestAsync({ body, timeout = 10000 }) {
                    return withTimeout(() => new Promise((onResponse, onError) => this.request({
                        body,
                        onError,
                        onResponse,
                    })), {
                        errorInstance: new TimeoutError({ body, url }),
                        timeout,
                    });
                },
                requests,
                subscriptions,
                url,
            };
            socketClientCache.set(url, socketClient);
            return [socketClient];
        },
    });
    const [_, [socketClient_]] = await schedule();
    return socketClient_;
}
//# sourceMappingURL=socket.js.map